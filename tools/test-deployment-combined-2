#!/usr/bin/env bash

# Verifies a deployment with
# the scheduler and storage in docker-compose
# workers in kubernetes.

set -eux -o pipefail -E

script_dir=$(dirname "${BASH_SOURCE[0]}")
root="$(realpath "$script_dir"/..)"
dockercompose_deployment="$root"/docker-compose
cd "$root"

abseil_output_base="abseil_output_base"

# We want special instance name prefix for this test,
# to make sure the workers within the 'docker-compose' deployment are used.
# But we do not want permanent changes to their configurations.
# It is better to have consistent configuration otherwise,
# to make it easy to compare them.

# NB: Open up the 'docker-compose' network to access the scheduler within 'minikube'.
# With the default network docker images cannot access 'localhost',
# so we change to the host network,
# and then punt the diagnostic servers away from port 80.

dockercompose_common_config="$dockercompose_deployment"/config/common.libsonnet
dockercompose_config="$dockercompose_deployment"/docker-compose.yml
kubernetes_worker_config="$root"/kubernetes/config/worker-ubuntu22-04.jsonnet
dockercompose_instance_name_prefix=--remote_instance_name=dockercompose

working_directory="$(realpath tmp-test-bare)"
mkdir "$working_directory"

# --- Launch kubernetes deployment with 'minikube' ---

sed -i "/^\s*concurrency: /a instanceNamePrefix: 'kubernetes'" "$kubernetes_worker_config"
# NB: Minikube retains the persistent volume date between restarts
# so we must delete the entire deployment.
minikube delete
minikube start
minikube kubectl -- apply -k "$root"/kubernetes

# Wait for pods to start
# TODO: find a sophisticated solution
sleep 70

# To allow bazel clients from outside
minikube kubectl -- -n buildbarn port-forward service/frontend 8980 &
# To allow buildbarn workers from outside
minikube kubectl -- -n buildbarn port-forward service/scheduler 8983 &
minikube kubectl -- -n buildbarn port-forward pod/storage-0 18981:8981 &
minikube kubectl -- -n buildbarn port-forward pod/storage-1 28981:8981 &
# TODO: To open the scheduler web ui
minikube kubectl -- -n buildbarn port-forward service/scheduler 7982 &

# NB: With kubectl and the minikube daemon
# finding the pid of the port-forward
# is a little bit involved.
# It is not sufficient to take the job process id '$?'
# TODO: Find a better 'ps' invocation to find the process.
# TODO: This is only valid if no one had the port open before,
# we do not want to kill unrelated programs.
# # sleep 5
# # port_forward_pid=$(lsof -i | grep 8980 | awk '{print $2}' | head -1)
sleep 25

# --- Launch worker from 'docker-compose' ---
cd "$dockercompose_deployment"
sed -i '/instanceNamePrefix/s#hardlinking#dockercompose#' "$dockercompose_worker_config"
sed -i "/^\s*scheduler: {/s/scheduler:8983/localhost:8983/" "$dockercompose_worker_config"
sed -i "/listenAddresses:/s#':80'#':11180'#" "$dockercompose_common_config"
sed -i "/^\s*worker-hardlinking-ubuntu22-04:/a \    network_mode: host" "$dockercompose_config"
sed -i "s/storage-0:8981/localhost:18981/" "$dockercompose_common_config"
sed -i "s/storage-1:8981/localhost:28981/" "$dockercompose_common_config"
docker-compose up runner-hardlinking-ubuntu22-04 worker-hardlinking-ubuntu22-04 &

cleanup() {
    EXIT_STATUS=$?
    # # kill "$port_forward_pid" || true
    # # wait "$port_forward_pid" || true
    rm -rf "$abseil_output_base"
    rm -rf "$working_directory"
    cd "$dockercompose_deployment"
    docker-compose down
    sed -i '/instanceNamePrefix/s#dockercompose#hardlinking#' "$dockercompose_worker_config"
    sed -i "/^\s*scheduler: {/s#localhost:8983#scheduler:8983#" "$dockercompose_worker_config"
    sed -i "/instanceNamePrefix: 'kubernetes'/d" "$kubernetes_worker_config"
    sed -i "/listenAddresses:/s#':11180'#':80'#" "$dockercompose_common_config"
    sed -i "s/localhost:18981/storage-0:8981/" "$dockercompose_common_config"
    sed -i "s/localhost:28981/storage-1:8981/" "$dockercompose_common_config"
    sed -i "/network_mode: host/d" "$dockercompose_config"
    return "$EXIT_STATUS"
}
trap cleanup EXIT

# --- Run remote execution ---
cd "$working_directory"

bazel --output_base="$abseil_output_base" clean
bazel --output_base="$abseil_output_base" \
    test --color=no --curses=no --config=remote-local --disk_cache= \
    "$dockercompose_instance_name_prefix" \
    --remote_default_exec_properties OSFamily=linux \
    --remote_default_exec_properties container-image="docker://ghcr.io/catthehacker/ubuntu:act-22.04@sha256:5f9c35c25db1d51a8ddaae5c0ba8d3c163c5e9a4a6cc97acd409ac7eae239448" \
    @abseil-hello//:hello_test
# Make sure there are remote executions but no cache hits.
# INFO: 39 processes: 9 internal, 30 remote.
grep -E '^INFO: [0-9]+ processes: .*[0-9]+ remote[.,]' \
    "$abseil_output_base/command.log" \
    | grep -v 'remote cache hit'
